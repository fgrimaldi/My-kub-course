# Readiness

sometimes applications are temporarily unable to serve traffic—for example, if the application needs to load large data or configuration files during startup. In such cases, you don’t want to kill the application, but you don’t want to send it requests either. Kubernetes provides readiness probes to detect and mitigate these situations.
Readiness probes are configured similarly to liveness probes. The only difference is that you use the readinessProbe field instead of the livenessProbe field.

## HTTP Get readiness probe

The following YAML listing creates a pod that includes an HTTP Get readiness probe:

```yaml
apiVersion: v1
kind: Pod
metadata:
  labels:
    test: readiness
  name: readiness-http
spec:
  containers:
  - name: readiness
    image: k8s.gcr.io/liveness
    args:
   - /server
    readinessProbe:
      httpGet:
        path: /healthz
        port: 8080
        httpHeaders:
        - name: X-Custom-Header
          value: Desotech
      initialDelaySeconds: 3
      periodSeconds: 3
```

## TCP socket readiness probe

The following YAML listing creates a pod that includes a TCP socket readiness probe:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: goproxy
  labels:
    app: goproxy
spec:
  containers:
  - name: goproxy
    image: k8s.gcr.io/goproxy:0.1
    ports:
    - containerPort: 8080
    readinessProbe:
      tcpSocket:
        port: 8080
      initialDelaySeconds: 5
      periodSeconds: 10
    livenessProbe:
      tcpSocket:
        port: 8080
      initialDelaySeconds: 15
      periodSeconds: 20
```

## Exec readiness probe

The following YAML listing creates a pod that includes an Exec readiness probe:

```YAML
apiVersion: v1
kind: Pod
metadata:
  labels:
    test: readiness
  name: readiness-exec
spec:
  containers:
  - name: readiness
    image: k8s.gcr.io/busybox
    args:
   - /bin/sh
    - -c
    - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600
    readinessProbe:
      exec:
        command:
       - cat
        - /tmp/healthy
      initialDelaySeconds: 5
      periodSeconds: 5
```

Kubernetes keeps your containers running by restarting them if they crash or if their liveness probes fail. This job is performed by the kubelet on the node hosting the pod.

If the node itself crashes, the control plane must replace all the pods running on that node. In this case, you can use a replication mechanism to recreate the pods on another node within the cluster. 
